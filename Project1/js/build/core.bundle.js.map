{"version":3,"file":"core.bundle.js","mappings":";;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACpyBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://project-1-native-js/./node_modules/melanke-watchjs/src/watch.js","webpack://project-1-native-js/./js/const/modals.js","webpack://project-1-native-js/./js/state/state.js","webpack://project-1-native-js/./js/watchers/watcher.js","webpack://project-1-native-js/webpack/bootstrap","webpack://project-1-native-js/webpack/runtime/compat get default export","webpack://project-1-native-js/webpack/runtime/define property getters","webpack://project-1-native-js/webpack/runtime/hasOwnProperty shorthand","webpack://project-1-native-js/webpack/runtime/make namespace object","webpack://project-1-native-js/./js/index.js"],"sourcesContent":["/**\r\n * DEVELOPED BY\r\n * GIL LOPES BUENO\r\n * gilbueno.mail@gmail.com\r\n *\r\n * WORKS WITH:\r\n * IE8*, IE 9+, FF 4+, SF 5+, WebKit, CH 7+, OP 12+, BESEN, Rhino 1.7+\r\n * For IE8 (and other legacy browsers) WatchJS will use dirty checking  \r\n *\r\n * FORK:\r\n * https://github.com/melanke/Watch.JS\r\n *\r\n * LICENSE: MIT\r\n */\r\n\r\n\"use strict\";\r\n(function (factory) {\r\n    if (typeof exports === 'object') {\r\n        // Node. Does not work with strict CommonJS, but\r\n        // only CommonJS-like enviroments that support module.exports,\r\n        // like Node.\r\n        module.exports = factory();\r\n    } else if (typeof define === 'function' && define.amd) {\r\n        // AMD. Register as an anonymous module.\r\n        define(factory);\r\n    } else {\r\n        // Browser globals\r\n        window.WatchJS = factory();\r\n        window.watch = window.WatchJS.watch;\r\n        window.unwatch = window.WatchJS.unwatch;\r\n        window.callWatchers = window.WatchJS.callWatchers;\r\n    }\r\n}(function () {\r\n\r\n    var WatchJS = {\r\n        noMore: false,        // use WatchJS.suspend(obj) instead\r\n        useDirtyCheck: false, // use only dirty checking to track changes.\r\n        preserveExistingSetters: false\r\n    },\r\n    lengthsubjects = [];\r\n    \r\n    var dirtyChecklist = [];\r\n    var pendingChanges = []; // used coalesce changes from defineProperty and __defineSetter__\r\n    \r\n    var supportDefineProperty = false;\r\n    try {\r\n        supportDefineProperty = Object.defineProperty && Object.defineProperty({},'x', {});\r\n    } catch(ex) {  /* not supported */  }\r\n\r\n    var isFunction = function (functionToCheck) {\r\n        var getType = {};\r\n        return functionToCheck && getType.toString.call(functionToCheck) == '[object Function]';\r\n    };\r\n\r\n    var isInt = function (x) {\r\n        return x % 1 === 0;\r\n    };\r\n\r\n    var isArray = function(obj) {\r\n        return Object.prototype.toString.call(obj) === '[object Array]';\r\n    };\r\n\r\n    var isObject = function(obj) {\r\n        return {}.toString.apply(obj) === '[object Object]';\r\n    };\r\n    \r\n    var getObjDiff = function(a, b){\r\n        var aplus = [],\r\n        bplus = [];\r\n\r\n        if(!(typeof a == \"string\") && !(typeof b == \"string\")){\r\n\r\n            if (isArray(a) && b) {\r\n                for (var i=0; i<a.length; i++) {\r\n                    if (b[i] === undefined) aplus.push(i);\r\n                }\r\n            } else {\r\n                for(var i in a){\r\n                    if (a.hasOwnProperty(i)) {\r\n                        if(b && !b.hasOwnProperty(i)) {\r\n                            aplus.push(i);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (isArray(b) && a) {\r\n                for (var j=0; j<b.length; j++) {\r\n                    if (a[j] === undefined) bplus.push(j);\r\n                }\r\n            } else {\r\n                for(var j in b){\r\n                    if (b.hasOwnProperty(j)) {\r\n                        if(a && !a.hasOwnProperty(j)) {\r\n                            bplus.push(j);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return {\r\n            added: aplus,\r\n            removed: bplus\r\n        }\r\n    };\r\n\r\n    var clone = function(obj){\r\n\r\n        if (null == obj || \"object\" != typeof obj) {\r\n            return obj;\r\n        }\r\n\r\n        var copy = obj.constructor();\r\n\r\n        for (var attr in obj) {\r\n            copy[attr] = obj[attr];\r\n        }\r\n\r\n        return copy;        \r\n\r\n    }\r\n\r\n    var getExistingSetter = function (obj, propName) {\r\n        if (WatchJS.preserveExistingSetters) {\r\n            var existing = Object.getOwnPropertyDescriptor(obj, propName);\r\n            return existing.set;\r\n        }\r\n\r\n        return undefined;\r\n    }\r\n\r\n    var defineGetAndSet = function (obj, propName, getter, setter) {\r\n        try {\r\n            var existingSetter = getExistingSetter(obj, propName);\r\n            Object.defineProperty(obj, propName, {\r\n                get: getter,\r\n                set: function(value) {\r\n                    setter.call(this, value, true); // coalesce changes\r\n                    if (existingSetter) {\r\n                        existingSetter(value);\r\n                    }\r\n                },\r\n                enumerable: true,\r\n                configurable: true\r\n            });\r\n        }\r\n        catch(e1) {\r\n            try{\r\n                Object.prototype.__defineGetter__.call(obj, propName, getter);\r\n                Object.prototype.__defineSetter__.call(obj, propName, function(value) {\r\n                    setter.call(this,value,true); // coalesce changes\r\n                });\r\n            }\r\n            catch(e2) {\r\n                observeDirtyChanges(obj,propName,setter);\r\n                //throw new Error(\"watchJS error: browser not supported :/\")\r\n            }\r\n        }\r\n\r\n    };\r\n\r\n    var defineProp = function (obj, propName, value) {\r\n        try {\r\n            Object.defineProperty(obj, propName, {\r\n                enumerable: false,\r\n                configurable: true,\r\n                writable: false,\r\n                value: value\r\n            });\r\n        } catch(error) {\r\n            obj[propName] = value;\r\n        }\r\n    };\r\n\r\n    var observeDirtyChanges = function(obj,propName,setter) {\r\n        dirtyChecklist[dirtyChecklist.length] = {\r\n            prop:       propName,\r\n            object:     obj,\r\n            orig:       clone(obj[propName]),\r\n            callback:   setter\r\n        }        \r\n    }\r\n    \r\n    var watch = function () {\r\n\r\n        if (isFunction(arguments[1])) {\r\n            watchAll.apply(this, arguments);\r\n        } else if (isArray(arguments[1])) {\r\n            watchMany.apply(this, arguments);\r\n        } else {\r\n            watchOne.apply(this, arguments);\r\n        }\r\n\r\n    };\r\n\r\n\r\n    var watchAll = function (obj, watcher, level, addNRemove) {\r\n\r\n        if ((typeof obj == \"string\") || (!(obj instanceof Object) && !isArray(obj))) { //accepts only objects and array (not string)\r\n            return;\r\n        }\r\n\r\n        if(isArray(obj)) {\r\n            defineWatcher(obj, \"__watchall__\", watcher, level); // watch all changes on the array\r\n            if (level===undefined||level > 0) {\r\n                for (var prop = 0; prop < obj.length; prop++) { // watch objects in array\r\n                   watchAll(obj[prop],watcher,level, addNRemove);\r\n                }\r\n            }\r\n        } \r\n        else {\r\n            var prop,props = [];\r\n            for (prop in obj) { //for each attribute if obj is an object\r\n                if (prop == \"$val\" || (!supportDefineProperty && prop === 'watchers')) {\r\n                    continue;\r\n                }\r\n\r\n                if (Object.prototype.hasOwnProperty.call(obj, prop)) {\r\n                    props.push(prop); //put in the props\r\n                }\r\n            }\r\n            watchMany(obj, props, watcher, level, addNRemove); //watch all items of the props\r\n        }\r\n\r\n\r\n        if (addNRemove) {\r\n            pushToLengthSubjects(obj, \"$$watchlengthsubjectroot\", watcher, level);\r\n        }\r\n    };\r\n\r\n\r\n    var watchMany = function (obj, props, watcher, level, addNRemove) {\r\n\r\n        if ((typeof obj == \"string\") || (!(obj instanceof Object) && !isArray(obj))) { //accepts only objects and array (not string)\r\n            return;\r\n        }\r\n\r\n        for (var i=0; i<props.length; i++) { //watch each property\r\n            var prop = props[i];\r\n            watchOne(obj, prop, watcher, level, addNRemove);\r\n        }\r\n\r\n    };\r\n\r\n    var watchOne = function (obj, prop, watcher, level, addNRemove) {\r\n        if ((typeof obj == \"string\") || (!(obj instanceof Object) && !isArray(obj))) { //accepts only objects and array (not string)\r\n            return;\r\n        }\r\n\r\n        if(isFunction(obj[prop])) { //dont watch if it is a function\r\n            return;\r\n        }\r\n        if(obj[prop] != null && (level === undefined || level > 0)){\r\n            watchAll(obj[prop], watcher, level!==undefined? level-1 : level); //recursively watch all attributes of this\r\n        }\r\n\r\n        defineWatcher(obj, prop, watcher, level);\r\n\r\n        if(addNRemove && (level === undefined || level > 0)){\r\n            pushToLengthSubjects(obj, prop, watcher, level);\r\n        }\r\n\r\n    };\r\n\r\n    var unwatch = function () {\r\n\r\n        if (isFunction(arguments[1])) {\r\n            unwatchAll.apply(this, arguments);\r\n        } else if (isArray(arguments[1])) {\r\n            unwatchMany.apply(this, arguments);\r\n        } else {\r\n            unwatchOne.apply(this, arguments);\r\n        }\r\n\r\n    };\r\n\r\n    var unwatchAll = function (obj, watcher) {\r\n\r\n        if (obj instanceof String || (!(obj instanceof Object) && !isArray(obj))) { //accepts only objects and array (not string)\r\n            return;\r\n        }\r\n\r\n        if (isArray(obj)) {\r\n            var props = ['__watchall__'];\r\n            for (var prop = 0; prop < obj.length; prop++) { //for each item if obj is an array\r\n                props.push(prop); //put in the props\r\n            }\r\n            unwatchMany(obj, props, watcher); //watch all itens of the props\r\n        } else {\r\n            var unwatchPropsInObject = function (obj2) {\r\n                var props = [];\r\n                for (var prop2 in obj2) { //for each attribute if obj is an object\r\n                    if (obj2.hasOwnProperty(prop2)) {\r\n                        if (obj2[prop2] instanceof Object) {\r\n                            unwatchPropsInObject(obj2[prop2]); //recurs into object props\r\n                        } else {\r\n                            props.push(prop2); //put in the props\r\n                        }\r\n                    }\r\n                }\r\n                unwatchMany(obj2, props, watcher); //unwatch all of the props\r\n            };\r\n            unwatchPropsInObject(obj);\r\n        }\r\n    };\r\n\r\n\r\n    var unwatchMany = function (obj, props, watcher) {\r\n\r\n        for (var prop2 in props) { //watch each attribute of \"props\" if is an object\r\n            if (props.hasOwnProperty(prop2)) {\r\n                unwatchOne(obj, props[prop2], watcher);\r\n            }\r\n        }\r\n    };\r\n\r\n    var timeouts = [],\r\n        timerID = null;\r\n    function clearTimerID() {\r\n        timerID = null;\r\n        for(var i=0; i< timeouts.length; i++) {\r\n            timeouts[i]();\r\n        }\r\n        timeouts.length = 0;\r\n    }\r\n    var getTimerID= function () {\r\n        if (!timerID)  {\r\n            timerID = setTimeout(clearTimerID);\r\n        }\r\n        return timerID;\r\n    }\r\n    var registerTimeout = function(fn) { // register function to be called on timeout\r\n        if (timerID==null) getTimerID();\r\n        timeouts[timeouts.length] = fn;\r\n    }\r\n    \r\n    // Track changes made to an array, object or an object's property \r\n    // and invoke callback with a single change object containing type, value, oldvalue and array splices\r\n    // Syntax: \r\n    //      trackChange(obj, callback, recursive, addNRemove)\r\n    //      trackChange(obj, prop, callback, recursive, addNRemove)\r\n    var trackChange = function() {\r\n        var fn = (isFunction(arguments[2])) ? trackProperty : trackObject ;\r\n        fn.apply(this,arguments);\r\n    }\r\n\r\n    // track changes made to an object and invoke callback with a single change object containing type, value and array splices\r\n    var trackObject= function(obj, callback, recursive, addNRemove) {\r\n        var change = null,lastTimerID = -1;\r\n        var isArr = isArray(obj);\r\n        var level,fn = function(prop, action, newValue, oldValue) {\r\n            var timerID = getTimerID();\r\n            if (lastTimerID!==timerID) { // check if timer has changed since last update\r\n                lastTimerID = timerID;\r\n                change = {\r\n                    type: 'update'\r\n                }\r\n                change['value'] = obj;\r\n                change['splices'] = null;\r\n                registerTimeout(function() {\r\n                    callback.call(this,change);\r\n                    change = null;\r\n                });\r\n            }\r\n            // create splices for array changes\r\n            if (isArr && obj === this && change !== null)  {                \r\n                if (action==='pop'||action==='shift') {\r\n                    newValue = [];\r\n                    oldValue = [oldValue];\r\n                }\r\n                else if (action==='push'||action==='unshift') {\r\n                    newValue = [newValue];\r\n                    oldValue = [];\r\n                }\r\n                else if (action!=='splice') { \r\n                    return; // return here - for reverse and sort operations we don't need to return splices. a simple update will do\r\n                }\r\n                if (!change.splices) change.splices = [];\r\n                change.splices[change.splices.length] = {\r\n                    index: prop,\r\n                    deleteCount: oldValue ? oldValue.length : 0,\r\n                    addedCount: newValue ? newValue.length : 0,\r\n                    added: newValue,\r\n                    deleted: oldValue\r\n                };\r\n            }\r\n\r\n        }  \r\n        level = (recursive==true) ? undefined : 0;        \r\n        watchAll(obj,fn, level, addNRemove);\r\n    }\r\n    \r\n    // track changes made to the property of an object and invoke callback with a single change object containing type, value, oldvalue and splices\r\n    var trackProperty = function(obj,prop,callback,recursive, addNRemove) { \r\n        if (obj && prop) {\r\n            watchOne(obj,prop,function(prop, action, newvalue, oldvalue) {\r\n                var change = {\r\n                    type: 'update'\r\n                }\r\n                change['value'] = newvalue;\r\n                change['oldvalue'] = oldvalue;\r\n                if (recursive && isObject(newvalue)||isArray(newvalue)) {\r\n                    trackObject(newvalue,callback,recursive, addNRemove);\r\n                }               \r\n                callback.call(this,change);\r\n            },0)\r\n            \r\n            if (recursive && isObject(obj[prop])||isArray(obj[prop])) {\r\n                trackObject(obj[prop],callback,recursive, addNRemove);\r\n            }                           \r\n        }\r\n    }\r\n    \r\n    \r\n    var defineWatcher = function (obj, prop, watcher, level) {\r\n        var newWatcher = false;\r\n        var isArr = isArray(obj);\r\n        \r\n        if (!obj.watchers) {\r\n            defineProp(obj, \"watchers\", {});\r\n            if (isArr) {\r\n                // watch array functions\r\n                watchFunctions(obj, function(index,action,newValue, oldValue) {\r\n                    addPendingChange(obj, index, action,newValue, oldValue);\r\n                    if (level !== 0 && newValue && (isObject(newValue) || isArray(newValue))) {\r\n                        var i,n, ln, wAll, watchList = obj.watchers[prop];\r\n                        if ((wAll = obj.watchers['__watchall__'])) {\r\n                            watchList = watchList ? watchList.concat(wAll) : wAll;\r\n                        }\r\n                        ln = watchList ?  watchList.length : 0;\r\n                        for (i = 0; i<ln; i++) {\r\n                            if (action!=='splice') {\r\n                                watchAll(newValue, watchList[i], (level===undefined)?level:level-1);\r\n                            }\r\n                            else {\r\n                                // watch spliced values\r\n                                for(n=0; n < newValue.length; n++) {\r\n                                    watchAll(newValue[n], watchList[i], (level===undefined)?level:level-1);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n\r\n        if (!obj.watchers[prop]) {\r\n            obj.watchers[prop] = [];\r\n            if (!isArr) newWatcher = true;\r\n        }\r\n\r\n        for (var i=0; i<obj.watchers[prop].length; i++) {\r\n            if(obj.watchers[prop][i] === watcher){\r\n                return;\r\n            }\r\n        }\r\n\r\n        obj.watchers[prop].push(watcher); //add the new watcher to the watchers array\r\n\r\n        if (newWatcher) {\r\n            var val = obj[prop];            \r\n            var getter = function () {\r\n                return val;                        \r\n            };\r\n\r\n            var setter = function (newval, delayWatcher) {\r\n                var oldval = val;\r\n                val = newval;                \r\n                if (level !== 0 \r\n                    && obj[prop] && (isObject(obj[prop]) || isArray(obj[prop]))\r\n                    && !obj[prop].watchers) {\r\n                    // watch sub properties\r\n                    var i,ln = obj.watchers[prop].length; \r\n                    for(i=0; i<ln; i++) {\r\n                        watchAll(obj[prop], obj.watchers[prop][i], (level===undefined)?level:level-1);\r\n                    }\r\n                }\r\n\r\n                //watchFunctions(obj, prop);\r\n                \r\n                if (isSuspended(obj, prop)) {\r\n                    resume(obj, prop);\r\n                    return;\r\n                }\r\n\r\n                if (!WatchJS.noMore){ // this does not work with Object.observe\r\n                    //if (JSON.stringify(oldval) !== JSON.stringify(newval)) {\r\n                    if (obj[prop] instanceof Date && oldval && newval) {\r\n                        oldval = oldval.valueOf();\r\n                        newval = newval.valueOf();\r\n                    }\t\r\n                    if (oldval !== newval) {\r\n                        if (!delayWatcher) {\r\n                            callWatchers(obj, prop, \"set\", newval, oldval);\r\n                        }\r\n                        else {\r\n                            addPendingChange(obj, prop, \"set\", newval, oldval);\r\n                        }\r\n                        WatchJS.noMore = false;\r\n                    }\r\n                }\r\n            };\r\n\r\n            if (WatchJS.useDirtyCheck) {\r\n                observeDirtyChanges(obj,prop,setter);\r\n            }\r\n            else {\r\n                defineGetAndSet(obj, prop, getter, setter);\r\n            }\r\n        }\r\n\r\n    };\r\n\r\n    var callWatchers = function (obj, prop, action, newval, oldval) {\r\n        if (prop !== undefined) {\r\n            var ln, wl, watchList = obj.watchers[prop];\r\n            if ((wl = obj.watchers['__watchall__'])) {\r\n                watchList = watchList ? watchList.concat(wl) : wl;\r\n            }\r\n            ln = watchList ? watchList.length : 0;\r\n            for (var wr=0; wr< ln; wr++) {\r\n                watchList[wr].call(obj, prop, action, newval, oldval);\r\n            }\r\n        } else {\r\n            for (var prop in obj) {//call all\r\n                if (obj.hasOwnProperty(prop)) {\r\n                    callWatchers(obj, prop, action, newval, oldval);\r\n                }\r\n            }\r\n        }\r\n    };\r\n\r\n    var methodNames = ['pop', 'push', 'reverse', 'shift', 'sort', 'slice', 'unshift', 'splice'];\r\n    var defineArrayMethodWatcher = function (obj, original, methodName, callback) {\r\n        defineProp(obj, methodName, function () {\r\n            var index = 0;\r\n            var i,newValue, oldValue, response;                        \r\n            // get values before splicing array \r\n            if (methodName === 'splice') {\r\n               var start = arguments[0];\r\n               var end = start + arguments[1];\r\n               oldValue = obj.slice(start,end);\r\n               newValue = [];\r\n               for(i=2;i<arguments.length;i++) {\r\n                   newValue[i-2] = arguments[i];\r\n               }\r\n               index = start;\r\n            } \r\n            else {\r\n                newValue = arguments.length > 0 ? arguments[0] : undefined;\r\n            } \r\n\r\n            response = original.apply(obj, arguments);\r\n            if (methodName !== 'slice') {\r\n                if (methodName === 'pop') {\r\n                    oldValue = response;\r\n                    index = obj.length;\r\n                }\r\n                else if (methodName === 'push') {\r\n                    index = obj.length-1;\r\n                }\r\n                else if (methodName === 'shift') {\r\n                    oldValue = response;\r\n                }\r\n                else if (methodName !== 'unshift' && newValue===undefined) {\r\n                    newValue = response;\r\n                }\r\n                callback.call(obj, index, methodName,newValue, oldValue)\r\n            }\r\n            return response;\r\n        });\r\n    };\r\n\r\n    var watchFunctions = function(obj, callback) {\r\n\r\n        if (!isFunction(callback) || !obj || (obj instanceof String) || (!isArray(obj))) {\r\n            return;\r\n        }\r\n\r\n        for (var i = methodNames.length, methodName; i--;) {\r\n            methodName = methodNames[i];\r\n            defineArrayMethodWatcher(obj, obj[methodName], methodName, callback);\r\n        }\r\n\r\n    };\r\n\r\n    var unwatchOne = function (obj, prop, watcher) {\r\n        if (prop) {\r\n            if (obj.watchers && obj.watchers[prop]) {\r\n                if (watcher === undefined) {\r\n                    delete obj.watchers[prop]; // remove all property watchers\r\n                }\r\n                else {\r\n                    for (var i = 0; i < obj.watchers[prop].length; i++) {\r\n                        var w = obj.watchers[prop][i];\r\n                        if (w == watcher) {\r\n                            obj.watchers[prop].splice(i, 1);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            delete obj.watchers;\r\n        }\r\n\r\n        removeFromLengthSubjects(obj, prop, watcher);\r\n        removeFromDirtyChecklist(obj, prop);\r\n    };\r\n    \r\n    // suspend watchers until next update cycle\r\n    var suspend = function(obj, prop) {\r\n        if (obj.watchers) {\r\n            var name = '__wjs_suspend__'+(prop!==undefined ? prop : '');\r\n            obj.watchers[name] = true;\r\n        }\r\n    }\r\n    \r\n    var isSuspended = function(obj, prop) {\r\n        return obj.watchers \r\n               && (obj.watchers['__wjs_suspend__'] || \r\n                   obj.watchers['__wjs_suspend__'+prop]);\r\n    }\r\n    \r\n    // resumes preivously suspended watchers\r\n    var resume = function(obj, prop) {\r\n        registerTimeout(function() {\r\n            delete obj.watchers['__wjs_suspend__'];\r\n            delete obj.watchers['__wjs_suspend__'+prop];\r\n        })\r\n    }\r\n\r\n    var pendingTimerID = null;\r\n    var addPendingChange = function(obj,prop, mode, newval, oldval) {\r\n        pendingChanges[pendingChanges.length] = {\r\n            obj:obj,\r\n            prop: prop,\r\n            mode: mode,\r\n            newval: newval,\r\n            oldval: oldval\r\n        };\r\n        if (pendingTimerID===null) {\r\n            pendingTimerID = setTimeout(applyPendingChanges);\r\n        }\r\n    };\r\n    \r\n    \r\n    var applyPendingChanges = function()  {\r\n        // apply pending changes\r\n        var change = null;\r\n        pendingTimerID = null;\r\n        for(var i=0;i < pendingChanges.length;i++) {\r\n            change = pendingChanges[i];\r\n            callWatchers(change.obj, change.prop, change.mode, change.newval, change.oldval);\r\n        }\r\n        if (change) {\r\n            pendingChanges = [];\r\n            change = null;\r\n        }        \r\n    }\r\n\r\n    var loop = function(){\r\n\r\n        // check for new or deleted props\r\n        for(var i=0; i<lengthsubjects.length; i++) {\r\n\r\n            var subj = lengthsubjects[i];\r\n\r\n            if (subj.prop === \"$$watchlengthsubjectroot\") {\r\n\r\n                var difference = getObjDiff(subj.obj, subj.actual);\r\n\r\n                if(difference.added.length || difference.removed.length){\r\n                    if(difference.added.length){\r\n                        watchMany(subj.obj, difference.added, subj.watcher, subj.level - 1, true);\r\n                    }\r\n\r\n                    subj.watcher.call(subj.obj, \"root\", \"differentattr\", difference, subj.actual);\r\n                }\r\n                subj.actual = clone(subj.obj);\r\n\r\n\r\n            } else {\r\n\r\n                var difference = getObjDiff(subj.obj[subj.prop], subj.actual);\r\n\r\n                if(difference.added.length || difference.removed.length){\r\n                    if(difference.added.length){\r\n                        for (var j=0; j<subj.obj.watchers[subj.prop].length; j++) {\r\n                            watchMany(subj.obj[subj.prop], difference.added, subj.obj.watchers[subj.prop][j], subj.level - 1, true);\r\n                        }\r\n                    }\r\n\r\n                    callWatchers(subj.obj, subj.prop, \"differentattr\", difference, subj.actual);\r\n                }\r\n\r\n                subj.actual = clone(subj.obj[subj.prop]);\r\n\r\n            }\r\n\r\n        }\r\n        \r\n        // start dirty check\r\n        var n, value;\r\n        if (dirtyChecklist.length > 0) {\r\n            for (var i = 0; i < dirtyChecklist.length; i++) {\r\n                n = dirtyChecklist[i];\r\n                value = n.object[n.prop];\r\n                if (!compareValues(n.orig, value)) {\r\n                    n.orig = clone(value);\r\n                    n.callback(value);\r\n                }\r\n            }\r\n        }\r\n\r\n    };\r\n\r\n    var compareValues =  function(a,b) {\r\n        var i, state = true;\r\n        if (a!==b)  {\r\n            if (isObject(a)) {\r\n                for(i in a) {\r\n                    if (!supportDefineProperty && i==='watchers') continue;\r\n                    if (a[i]!==b[i]) {\r\n                        state = false;\r\n                        break;\r\n                    };\r\n                }\r\n            }\r\n            else {\r\n                state = false;\r\n            }\r\n        }\r\n        return state;\r\n    }\r\n    \r\n    var pushToLengthSubjects = function(obj, prop, watcher, level){\r\n\r\n        var actual;\r\n\r\n        if (prop === \"$$watchlengthsubjectroot\") {\r\n            actual =  clone(obj);\r\n        } else {\r\n            actual = clone(obj[prop]);\r\n        }\r\n\r\n        lengthsubjects.push({\r\n            obj: obj,\r\n            prop: prop,\r\n            actual: actual,\r\n            watcher: watcher,\r\n            level: level\r\n        });\r\n    };\r\n\r\n    var removeFromLengthSubjects = function(obj, prop, watcher){\r\n        for (var i=0; i<lengthsubjects.length; i++) {\r\n            var subj = lengthsubjects[i];\r\n\r\n            if (subj.obj == obj) {\r\n                if (!prop || subj.prop == prop) {\r\n                    if (!watcher || subj.watcher == watcher) {\r\n                        // if we splice off one item at position i\r\n                        // we need to decrement i as the array is one item shorter\r\n                        // so when we increment i in the loop statement we\r\n                        // will land at the correct index.\r\n                        // if it's not decremented, you won't delete all length subjects\r\n                        lengthsubjects.splice(i--, 1);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n    };\r\n    \r\n    var removeFromDirtyChecklist = function(obj, prop){\r\n        var notInUse;\r\n        for (var i=0; i<dirtyChecklist.length; i++) {\r\n            var n = dirtyChecklist[i];\r\n            var watchers = n.object.watchers;\r\n            notInUse = (\r\n                n.object == obj \r\n                && (!prop || n.prop == prop)\r\n                && watchers\r\n                && (!prop || !watchers[prop] || watchers[prop].length == 0 )\r\n            );\r\n            if (notInUse)  {\r\n                // we use the same syntax as in removeFromLengthSubjects\r\n                dirtyChecklist.splice(i--, 1);\r\n            }\r\n        }\r\n\r\n    };    \r\n\r\n    setInterval(loop, 50);\r\n\r\n    WatchJS.watch = watch;\r\n    WatchJS.unwatch = unwatch;\r\n    WatchJS.callWatchers = callWatchers;\r\n    WatchJS.suspend = suspend; // suspend watchers    \r\n    WatchJS.onChange = trackChange;  // track changes made to object or  it's property and return a single change object\r\n\r\n    return WatchJS;\r\n\r\n}));\r\n","export const MODALS_TYPES = {\n  NONE: 'none',\n  SHOWS: 'shows',\n  DOGS: 'dogs',\n  MAKEUP: 'makeup'\n};\nexport const BUTTONS = [{\n  text: 'TV SHOWS',\n  type: MODALS_TYPES.SHOWS\n}, {\n  text: 'GET A DOG',\n  type: MODALS_TYPES.DOGS\n}, {\n  text: 'MAKEUP PRODUCTS',\n  type: MODALS_TYPES.MAKEUP\n}];\nexport const MODALS = [{\n  text: 'Enter the title of TV show ang get it!',\n  type: MODALS_TYPES.SHOWS\n}, {\n  text: 'Select a breed of dog and get picture!',\n  type: MODALS_TYPES.DOGS\n}, {\n  text: 'Select brand and type of product and get all products!',\n  type: MODALS_TYPES.MAKEUP\n}];","import { MODALS_TYPES } from \"@/const/modals\";\nexport default {\n  openedModalType: MODALS_TYPES.NONE\n};","import WatchJS from 'melanke-watchjs';\nimport state from '../state/state';\nimport { MODALS_TYPES } from \"@/const/modals\";\nconst watch = WatchJS.watch;\nwatch(state, 'openedModalType', () => {\n  const allWidgets = document.querySelectorAll('.widget');\n  allWidgets.forEach(item => {\n    item.style.display = \"none\";\n  });\n\n  if (state.openedModalType !== MODALS_TYPES.NONE) {\n    const widget = document.querySelector(`.widget[data-type=\"${state.openedModalType}\"]`);\n    widget.style.display = \"block\";\n  }\n});","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { BUTTONS, MODALS, MODALS_TYPES } from \"./const/modals\";\nimport state from \"./state/state\";\nimport './watchers/watcher';\n\nconst renderButtons = () => {\n  const buttons = document.querySelector('.buttons');\n  BUTTONS.forEach(item => {\n    const button = document.createElement('button');\n    button.classList.add('btnWidget');\n    const buttonText = document.createElement('p');\n    buttonText.textContent = item.text;\n    button.dataset.type = item.type;\n    button.appendChild(buttonText);\n    button.addEventListener('click', event => {\n      state.openedModalType = item.type;\n      event.stopPropagation();\n    });\n    buttons.append(button);\n  });\n};\n\nconst renderModals = () => {\n  const page = document.querySelector('.wholePage');\n  MODALS.forEach(item => {\n    const widget = document.createElement('div');\n    widget.classList.add('widget');\n    widget.dataset.type = item.type;\n    const widgetText = document.createElement('p');\n    widgetText.textContent = item.text;\n    const exitButton = document.createElement('button');\n    exitButton.classList.add(\"exitButton\");\n    const exitIcon = document.createElement('div');\n    exitIcon.classList.add(\"iconButton\");\n    exitIcon.textContent = \"X\";\n    exitButton.addEventListener(\"click\", event => {\n      state.openedModalType = MODALS_TYPES.NONE;\n      event.stopPropagation();\n    });\n    const nextButton = document.createElement('button');\n    nextButton.classList.add(\"nextButton\");\n    const nextIcon = document.createElement('div');\n    nextIcon.classList.add(\"iconButton\");\n    nextIcon.textContent = \">\";\n    nextButton.addEventListener(\"click\", event => {\n      const currentWidgetIndex = BUTTONS.findIndex(item => item.type === state.openedModalType);\n\n      if (currentWidgetIndex === BUTTONS.length - 1) {\n        state.openedModalType = BUTTONS[0].type;\n      } else {\n        state.openedModalType = BUTTONS[currentWidgetIndex + 1].type;\n      }\n\n      event.stopPropagation();\n    });\n    const prevButton = document.createElement('button');\n    prevButton.classList.add(\"prevButton\");\n    const prevIcon = document.createElement('div');\n    prevIcon.classList.add(\"iconButton\");\n    prevIcon.textContent = \"<\";\n    prevButton.addEventListener(\"click\", event => {\n      const currentWidgetIndex = BUTTONS.findIndex(item => item.type === state.openedModalType);\n\n      if (currentWidgetIndex === 0) {\n        state.openedModalType = BUTTONS[BUTTONS.length - 1].type;\n      } else {\n        state.openedModalType = BUTTONS[currentWidgetIndex - 1].type;\n      }\n\n      event.stopPropagation();\n    });\n    prevButton.append(prevIcon);\n    exitButton.append(exitIcon);\n    nextButton.append(nextIcon);\n    widget.append(nextButton);\n    widget.append(exitButton);\n    widget.append(prevButton);\n    widget.append(widgetText);\n    page.append(widget);\n\n    switch (item.type) {\n      case MODALS_TYPES.SHOWS:\n        const input = document.createElement('input');\n        const searchButton = document.createElement('button');\n        searchButton.textContent = \"Search\";\n        searchButton.classList.add(\"searchButton\");\n        const content = document.createElement('div');\n        content.classList.add(\"widgetContent\");\n        searchButton.addEventListener('click', () => {\n          document.querySelectorAll('.films').forEach(item => item.remove());\n          fetch(\"https://api.tvmaze.com/search/shows?q=\" + input.value).then(response => response.json()).then(data => data.forEach(item => {\n            const film = document.createElement('div');\n            film.classList.add(\"films\");\n            const site = document.createElement('div');\n            site.classList.add(\"site\");\n            const siteURL = document.createElement('a');\n            siteURL.classList.add(\"siteURL\");\n            siteURL.href = item.show.officialSite;\n            siteURL.textContent = item.show.name;\n            site.append(siteURL);\n            film.append(site);\n            const image = document.createElement(\"div\");\n            image.classList.add(\"images\");\n            const img = document.createElement('img');\n            img.classList.add('image');\n            img.src = item.show.image.original;\n            image.append(img);\n            film.append(image);\n            content.append(film);\n          }).catch(err => alert(err)));\n          input.value = \"\";\n          widget.append(content);\n        });\n        widget.append(input);\n        widget.append(searchButton);\n        break;\n\n      case MODALS_TYPES.DOGS:\n        const select = document.createElement(\"div\");\n        select.classList.add(\"selectDog\");\n        const selectBreed = document.createElement(\"select\");\n        select.append(selectBreed);\n        const breeds = [\"affenpinscher\", \"african\", \"airedale\", \"akita\", \"appenzeller\", \"basenji\", \"beagle\", \"bluetick\", \"borzoi\", \"bouvier\", \"boxer\", \"brabancon\", \"briard\", \"chihuahua\", \"chow\", \"clumber\", \"cockapoo\", \"coonhound\", \"cotondetulear\", \"dachshund\", \"dalmatian\", \"dhole\", \"dingo\", \"doberman\", \"entlebucher\", \"eskimo\", \"germanshepherd\", \"golden\", \"groenendael\", \"havanese\", \"husky\", \"keeshond\", \"kelpie\", \"komondor\", \"kuvasz\", \"labradoodle\", \"labrador\", \"leonberg\", \"lhasa\", \"malamute\", \"malinois\", \"maltese\", \"mexicanhairless\", \"mix\", \"newfoundland\", \"otterhound\", \"papillon\", \"pekinese\", \"pembroke\", \"pitbull\", \"pomeranian\", \"pug\", \"puggle\", \"pyrenees\", \"whippet\", \"weimaraner\", \"vizsla\", \"tervuren\", \"stbernard\", \"shihtzu\", \"shiba\", \"sharpei\", \"saluki\"];\n        breeds.forEach(breed => {\n          const option = document.createElement(\"option\");\n          option.textContent = breed;\n          option.value = breed;\n          selectBreed.add(option);\n        });\n        selectBreed.addEventListener('change', () => {\n          let selectedBreed = document.querySelector('select').selectedIndex;\n          let breed = selectBreed[selectedBreed].text;\n          fetch(\"https://dog.ceo/api/breed/\" + breed + \"/images/random\").then(response => response.json()).then(data => {\n            const dogIMG = document.createElement(\"div\");\n            dogIMG.classList.add(\"dogImage\");\n            const img = document.createElement('img');\n            img.classList.add(\"dogImg\");\n            img.src = data.message;\n            dogIMG.append(img);\n            widget.append(dogIMG);\n          }).catch(err => alert(err));\n          document.querySelector(\".dogImage\").remove();\n        });\n        widget.append(select);\n        break;\n\n      case MODALS_TYPES.MAKEUP:\n        const selectors = document.createElement(\"div\");\n        selectors.classList.add(\"selectors\");\n        const selectBrand = document.createElement(\"select\");\n        selectBrand.classList.add(\"brand\");\n        const brands = [\"almay\", \"alva\", \"annabelle\", \"benefit\", \"boosh\", \"clinique\", \"colourpop\", \"covergirl\", \"dalish\", \"deciem\", \"dior\", \"essie\", \"fenty\", \"glossier\", \"iman\", \"l'oreal\", \"marcelle\", \"marienatie\", \"maybelline\", \"milani\", \"misa\", \"mistura\", \"moov\", \"nudus\", \"nyx\", \"orly\", \"pacifica\", \"revlon\", \"sante\", \"stila\", \"smashbox\", \"suncoat\", \"zorah\"];\n        brands.forEach(brand => {\n          const option = document.createElement(\"option\");\n          option.textContent = brand;\n          option.value = brand;\n          selectBrand.add(option);\n        });\n        const selectProduct = document.createElement(\"select\");\n        selectProduct.classList.add(\"product\");\n        const products = [\"blush\", \"bronzer\", \"eyebrow\", \"eyeliner\", \"eyeshadow\", \"foundation\", \"lipstick\", \"mascara\"];\n        products.forEach(product => {\n          const option = document.createElement(\"option\");\n          option.textContent = product;\n          option.value = product;\n          selectProduct.add(option);\n        });\n        selectProduct.addEventListener(\"change\", () => {\n          document.querySelectorAll('.productCard').forEach(item => item.remove());\n          let selectedBrand = document.querySelector('.brand').selectedIndex;\n          let selectedProduct = document.querySelector(\".product\").selectedIndex;\n          let brand = selectBrand[selectedBrand].text;\n          let product = selectProduct[selectedProduct].text;\n          fetch(\"http://makeup-api.herokuapp.com/api/v1/products.json?brand=\" + brand + \"&product_type=\" + product).then(response => response.json()).then(data => data.forEach(item => {\n            const productCard = document.createElement('div');\n            productCard.classList.add(\"productCard\");\n            const site = document.createElement('div');\n            site.classList.add(\"site\");\n            const productName = document.createElement(\"a\");\n            productName.classList.add(\"siteURL\");\n            productName.href = item.product_link;\n            productName.textContent = item.name;\n            const price = document.createElement(\"div\");\n            const priceText = document.createElement(\"p\");\n            priceText.textContent = item.price + \" $\";\n            price.append(priceText);\n            const image = document.createElement(\"div\");\n            image.classList.add(\"images\");\n            let img = document.createElement(\"img\");\n            img.classList.add(\"image\");\n            img.src = item.image_link;\n            image.append(img);\n            site.append(productName);\n            productCard.append(site);\n            productCard.append(image);\n            productCard.append(price);\n            widget.append(productCard);\n          })).catch(err => alert(err));\n        });\n        selectors.append(selectBrand);\n        selectors.append(selectProduct);\n        widget.append(selectors);\n    }\n  });\n};\n\nrenderButtons();\nrenderModals();"],"names":[],"sourceRoot":""}